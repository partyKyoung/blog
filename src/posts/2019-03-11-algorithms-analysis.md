---
title: 알고리즘 분석
date: 2019-03-11 00:27:29
description: 설계한 알고리즘은 무엇보다 정확하고 효율적인 알고리즘이어야 한다.
path: /base/algorithms/analysis
---

설계한 알고리즘은 무엇보다 정확하고 효율적인 알고리즘이어야 한다.

## 정확성 분석

정확한 알고리즘이라면 유효한 입력이 주어졌을 때 유한 시간 내에 정확한 결과를 생성해야 한다. 정확성 분석을 위해서는 다양한 수학적 기법을 사용하여 알고리즘이 예상한 대로 수행되는지에 대해 증명해야 한다.

## 효율성 분석

알고리즘 분석의 대부분의 경우 알고리즘이 주어진 문제를 시간적으로 또는 공간적으로 얼마나 효울적으로 풀 수 있는지를 판단하는 것을 의미한다. 해당 알고리즘을 수행하기 위해서 필요한 메모리의 양과 수행 시간을 통해서 효울성을 평가한다.

효율적인 알고리즘이란 '가능한 한 적은 메모리와 보다 빠른 수행 시간을 갖는 알고리즘'을 의미한다.

### 공간 복잡도

알고리즘을 실행시켜 완료할 때까지 필요한 총 메모리의 양을 말한다.

### 시간 복잡도

알고리즘을 실행시켜 완료될 때까지 걸리는 시간을 말한다. 이때 알고리즘을 평가하는 컴퓨터 환경, 프로그래밍 언어, 프로그램 작성 방법 등의 종속적인 요인을 배제해야만 객관적인 평가가 가능하다.

알고리즘의 수행 시간은 입력크기 n이 증가하면 수행 시간도 증가한다. 따라서 알고리즘의 수행 시간을 단순히 수행되는 단위 연산의 개수의 합으로 표현하기보다는 입력 크기 n에 대한 함수로 표현 하는 것이 바람직하다.

또한 알고리즘의 수행 시간은 주어진 입력 데이터의 상태에 따라 영향을 받는다. 예를 들어 정렬 알고리즘의 경우 데이터가 이미 정렬된 상태로 주어질 때 가장 빠른 수행 시간을 보이지만 데이터가 무작위인 경우에는 가장 나쁜 성능을 보여준다. 알고리즘에 입력되는 데이터의 상태가 항상 최적이라고는 가정할 수 없으므로 최선의 수행 시간이 아닌 일반적인 상황에서 소요되는 시간을 추정하는 것이 바람직하다.

평균 수행 시간을 택하는 것이 좋으나 일반적으로 평균 수행 시간을 구하는 과정에서 모든 경우의 입력상태와 그에 대한 각각의 수행 시간을 알기 어렵기 때문에 보통 '최악의 수행 시간'을 알고리즘의 시간 복잡도를 평가하는 일반적인 척도로 사용한다.

**최악 수행 시간**: 알고리즘 수행 시간의 상한을 의미한다. 어떤 입력이 주어지더라도 이것 이상의 수행 시간은 걸리지 않는 다는 것을 보장하는 수행 시간이다.

### 알고리즘의 시간 복잡도 구하기

1. 알고리즘 수행시간 f(n)을 구한다.
2. f(n) = O(g(n))을 만족하는 최소 차수의 함수 g(n)을 찾는다.

=> 실용적인 접근방법: 알고리즘에 나타난 루프의 반복 횟수를 조사한 후 시간 복잡도로 취합한다. 이때 g(n)은 최고 차수에 의존한다.

ex)

```c
i = 1; // n

while (i <= n) { // n + 1
  x = x + 1; // n
  i = i + 1; // n
}
```

루프가 while문 하나 이므로 알고리즘의 시간 복잡도는 O(n)이다.

```c
int i, j;

for (i=1; i < n; i++) { //n
  for(j = i; j < n; j++) { // n x n
    if (i > j) {
      sum = i + j;
    }
  }
}
```

for 문이 이중으로 중첩되어 있으므로 시간 복잡도는 O($n^2$)이다.

## 점근성능

입력크기 n이 무한대로 커짐에 따라 결정되는 성능.

|  n  | 10n + 9 | $n^2 / 2 + 3n$ |
| :-: | :-----: | :------------: |
|  5  |   59    |      27.5      |
| 10  |   109   |       80       |
| 15  |   159   |     157.6      |
| 16  |   169   |      176       |
| 20  |   209   |      260       |
| 21  |   219   |     283.5      |
| ... |   ...   |      ...       |

시간 복잡도는 입력크기 n에 대한 함수로 표현되는데 n이 무한대로 커짐에 따라 알고리즘에 가장 큰 영향을 끼치는 것은 최고차항이다. 결국 점근성능은 수행 시간의 다항식 함수에서 최고차항만을 계수 없이 취해서 단순화시킨 형태가 된다.

점근성능의 표기법으로는 Big-O, Big-Ω, Big-⍬ 표기법이 있다. 표기법에서 f(n)은 알고리즘의 수행시간을 나타낸다.

### Big-O 표기법

어떤 양의 상수 c와 $n_0$이 존재하여 모든 n >= $n_0$에 대하여 f(n) <= cg(n)이면 f(n) = O(g(n))이다. 이때 O(n)은 최악의 수행시간이다.

f(n)이 O(g(n))이라는 것은 입력크기 n이 $n_0$ 이상으로 무한히 증가하더라도 f(n)의 값은 cg(n)보다 절대로 커질 수 없다는 의미로 G(n)을 상한으로 간주하기 때문에 함수의 점근적 상한을 나타낸다.

알고리즘의 시간 복잡도는 일반적으로 O- 표기를 사용해서 나타낸다. 아래와 같은 O- 표기법을 주로 사용한다. 맨 왼쪽의 상수 시간이 효율성이 제일 좋으며 오른쪽으로 갈 수록 비효율적이다.
O(1) < O($logn$) < O(n) < O($nlong$) < O($n^2$) < O($n^3$) < O($2^n$)

### Big-Ω 표기법

어떤 양의 상수 c와 $n_0$이 존재하여 모든 n >= $n_0$에 대하여 f(n) >= cg(n)이면 f(n) = Ω(g(n))이다. 이때 Ω(g(n))은 최상의 수행시간이다.

### Big-⍬ 표기법

어떤 양의 상수 c와 $n_0$이 존재하여 모든 n >= $n_0$에 대하여 $c_1$g(n) <= f(n) <= $c_2$g(n)이면 f(n) = ⍬(g(n))이다. 이때 ⍬(g(n))은 상한과 하한의 평균시간 이다.

점근적 상한과 하한을 동시에 갖는 경우로서 다른 표기법보다 성능을 정밀하게 나타낼 수 있다.

## 효율적인 알고리즘의 중요성

동일한 문제를 해결하는 알고리즘이 여러 개 존재한다면 입력 크기 n이 증가하더라도 알고리즘의 수행 시간이 상대적으로 적게 증가하는 알고리즘을 선택해야 한다. 입력크기가 작으면 어느 알고리즘을 사용해도 수행 시간의 차이가 별로 없지만, 입력 크기가 크면 클 수록 수행 시간의 차이가 확연하게 나타나므로 효율적인 알고리즘을 설계하거나 선택하는 것이 중요하다.

|  n  | f(n) = $logn$ | f(n) = n | f(n) = $nlogn$ | f(n) = $n^2$ | f(n) = $n^3$ | f(n) = $2^n$ |
| :-: | :-----------: | :------: | :------------: | :----------: | :----------: | :----------: |
|  1  |       0       |    1     |       0        |      1       |      1       |      2       |
|  2  |       1       |    2     |       2        |      4       |      8       |      4       |
|  4  |       2       |    4     |       8        |      16      |      64      |      16      |
|  8  |       3       |    8     |       24       |      64      |     512      |     256      |
| 16  |       4       |    16    |       64       |     256      |     4096     |    65536     |
| 32  |       5       |    32    |      160       |     1024     |    32768     |  4294967296  |

## 순환 알고리즘의 성능

**순환(재귀) 알고리즘**: 알고리즘 수행 과정에서 자기 자신의 알고리즘을 다시 수행하는 형태.

순환 알고리즘의 수행 시간을 나타내기 위한 방법으로 점화식이 사용된다.

|                                        점화식                                         |      폐쇄형       |                          비고                           |
| :-----------------------------------------------------------------------------------: | :---------------: | :-----------------------------------------------------: |
|    T(n) = $\begin{cases} ⍬(1), & n = 1 \\\ T(n - 1) + ⍬(1), & n >= 2 \end{cases}$     |    T(n) = ⍬(n)    |                                                         |
|    T(n) = $\begin{cases} ⍬(1), & n = 1 \\\ T(n - 1) + ⍬(n), & n >= 2 \end{cases}$     |  T(n) = ⍬($n^2$)  |               퀵 정렬의 최악의 수행 시간                |
| T(n) = $\begin{cases} ⍬(1), & n = 1 \\\ T(\frac{n}{2}) + ⍬(1), & n >= 2 \end{cases}$  | T(n) = ⍬($logn$)  |                  이진 탐색의 수행 시간                  |
| T(n) = $\begin{cases} ⍬(1), & n = 1 \\\ T(\frac{n}{2}) + ⍬(n), & n >= 2 \end{cases}$  |   T(n) = ⍬($n$)   |                                                         |
| T(n) = $\begin{cases} ⍬(1), & n = 1 \\\ 2T(\frac{n}{2}) + ⍬(1), & n >= 2 \end{cases}$ |   T(n) = ⍬($n$)   |                                                         |
| T(n) = $\begin{cases} ⍬(1), & n = 1 \\\ 2T(\frac{n}{2}) + ⍬(n), & n >= 2 \end{cases}$ | T(n) = ⍬($nlogn$) | 합병 정렬의 수행 시간, <br/> 퀵 정렬의 최선의 수행 시간 |

## Reference

- [방송대 컴퓨터과학과 알고리즘 2강](http://press.knou.ac.kr/goods/textBookView.do?condCmdtCode=9788920026935&condLscValue=001&condYr=&condSmst=)
