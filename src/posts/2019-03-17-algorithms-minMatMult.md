---
title: 연쇄 행렬 곱셈 문제
date: 2019-05-12 23:30:07
description: n개의 행렬을 연쇄적으로 곱할 때 최적의 곱셈 순서를 구하는 문제.
path: /base/algorithms/min-mat-mult
---

## 연쇄 행렬 곱셈 문제

n개의 행렬을 연쇄적으로 곱할 때 최적의 곱셈 순서를 구하는 문제. 즉 최소의 기본 곱셈 횟수를 가진 행렬의 곱셈 순서를 구하는 문제이다.

i x j 행렬과 j x k 행렬을 곱하는데에는 i x j x k번만큼의 곱셈이 필요하고 그 결과로는 i x k 번의 행렬을 얻는다. 행렬의 곱셈 연산은 결합법칙이 성립하기 때문에 n개의 행렬을 연쇄적으로 곱하는 경우에는 곱하는 순서에 따라 여러 가지 다른 방법으로 계산될 수 있다. 즉 어떤 순서로 곱하느냐에 따라 곱셈 횟수가 달라질 수 있다.

M1: 30 x 5
M2: 5 x 20
M3: 20 x 15
M4: 15 x 10

이렇게 행렬이 있다고 가정하면

M1 (M2 (M3M4)) = (20 x 15 x 10) + (5 x 20 x 10) + (30 x 5 x 10) = 5,500
(M1M2)(M3M4) = (30 x 5 x 20) + (20 x 15 x 10) + (30 x 20 x 10) - 12,000
M1( (M2M3) M4) = (5 x 20 x 15) + (5 x 15 x 10 ) + (30 x 5 x 10) = 3,750
((M1M2) M3 )M4 = (30 x 5 x 20) + (30 x 20 x 15) + (30 x 15 x 10) = 16,500
(M1 (M2M3))M4 = (5 x 20 x 15) + (30 x 5 x 15) + (30 x 15 x 10) = 6,900

위와 같은 결과가 나온다. 즉 M1( (M2M3) M4) 순으로 곱하면 우리가 원하는 최종적인 결과를 얻을 수 있다.

## 연쇄 행렬 곱셉 문제에서의 최적성의 원리.

n개의 행렬을 곱하는 최적의 순서는 n개의 행렬의 어떤 부분집합을 곱하는 최적의 순서를 포함한다.

ex)
7개 행렬을 곱하는 최적의 순서를 (M1M2)( (((M3M4) M5) M6) M7) 이라고 할 때 M3, M4, M5를 곱하는 최적의 순서는 ((M3M4) M5) 이다.
이렇게 부분 문제들의 최적해로 n개 행렬을 곱하는 최적의 순서를 구할 수 있기 때문에 최적성의 원리가 성립하므로 동적 프로그래밍 방법으로 해결 가능하다.

## 연쇄 행렬 곱셈 문제의 점화식

n개의 행렬 $M_i$($D_{i-1}$ x $D_i$)(1 <= i < n)를 아래와 같이 연쇄적으로 곱하는 문제를 생각해보자.

$M_1$ x $M_2$ x $M_3$ x ... x $M_{n-1}$ x $M_n$ = ($d_0$ x $d_1$) x ($d_1$ x $d_2$) x ($d_2$ x $d_3$) x ... x ($d_{n-2}$ x $d_{n-1}$) x ($d_{n-1}$ x $d_n$)

최적해를 구축하기 위해서 테이블 C[][]를 다음과 같이 정의한다.

- **C(i, j)** = $M_i$ x $M_{i+1}$ x ... x $M_{j-1}$ x $M_j$ 를 수행하는데 필요한 곱셈의 최소 횟수(비용).

C(i, i) -> C(i, i + 1) -> C(i, i + 2) -> ... -> C(1, n) 순으로 계산하므로 따라서 구하려는 n개 행렬을 연쇄적으로 곱하는데 필요한 최소 곱셈의 횟수는 C(1, n)이 된다.

- C(i, i) = 0
- C(i, i + 1) = $d_{i-1}$$d_i$$d_{i+1}$ => $d_{i-1}$ x $d_{i+1}$
- C(i, i + 2) = min{$M_i$($M_{i+1}$$M_{i+2}$)) + 결합비용, ($M_i$$M_{i+1}$)$M_{i+2}$ + 결합비용} = min{C(i,i) + C(i + 1, i + 2) + $d_{i-1}$$d_i$$d_{i+2}$, C(i, i+1) + C(i+2, i+2) + $d_{i-1}$$d_{i+1}$$d_{i+2}$}
- C(i, i+3) = min{$M_i$($M_{i+1}$$M_{i+2}$$M_{i+3}$) + 결합비용, ($M_i$$M_{i+1}$)($M_{i+2}$$M_{i+3}$) + 결합비용, ($M_i$$M_{i+1}$$M_{i+2}$)$M_{i+3}$ + 결합비용} = min{C(i, i) + C(i+1, i+3) + $d_{i-1}$$d_i$$d_{i+3}$, C(i, i+1) + C(i+2, i+3) + $d_{i-1}$$d_{i+1}$$d_{i+3}$, C(i, i+2) + C(i+3, i+3) + $d_{i-1}$$d_{i+2}$$d_{i+3}$}

즉 점화식은 다음과 같다.

- **C(i, j)** = min{($M_i$ ... $M_k$)($M_{k+1}$ ... $M_j$) + 결합비용} = min{C(i, k) + C(k + 1,j) + $d_{i-1}$$d_k$$d_j$} (i <= k <= j-1)
- C(i, i) = 0

## 알고리즘

```c
#include <stdio.h>
#include <stdlib.h>
#define MAX_VALUE 9999999

int min (int a, int b) {
  if ( a < b ) {
    return a;
  }

  return b;
}

/**
 * length: 행렬의 갯수
 * d[]: 정수 배열
*/
int minMatMult (int length, int d[]) {
  // n개의 행렬을 곱하는데 필요한 곱셈 횟수의 최솟값을 저장하는 배열.
  int **matrix =  malloc(sizeof(int) * length);

  for (int i = 0; i <= length; i++) {
    matrix[i] =  malloc(sizeof(int) * length);
  }

  // mtarix[i][i] 초기화.
  for (int i = 1; i <= length; i++) {
    matrix[i][i] = 0;
  }

  for (int f = 1; f <= length - 1; f++) {
    for (int n = 1; n <= length - f; n++) {
      int j = f + n;

      matrix[n][j] = MAX_VALUE;

      for (int k = n; k <= j - 1; k++) {
        matrix[n][j] = min(matrix[n][j], matrix[n][k] + matrix[k + 1][j] + d[n - 1] * d[k] * d[j]);
      }
    }
  }

  int value = matrix[1][length];

  free(matrix);

  return value;
}
```

## 작동 방법

3 x 2, 2 x 4, 4 x 1인 세개의 행렬 M1, M2, M3이 있다고 할 때 여기서 d0 = 3, d1 = 2, d2 = 4, d3 = 1 이므로 d[] = { 3, 2, 4, 1 }, length = 3 이 된다.

1. 초기화

|     |  1  |  2  |  3  |
| --- | :-: | :-: | :-: |
| 1   |  0  |     |     |
| 2   |     |  0  |     |
| 3   |     |     |  0  |

C(i, i) = 0 이므로 먼저 초기값을 세팅해준다.

2. f = 1, n = 1, j = 2

|     |  1  |  2  |  3  |
| --- | :-: | :-: | :-: |
| 1   |  0  | 24  |     |
| 2   |     |  0  |     |
| 3   |     |     |  0  |

C(1, 2) = min{C(1, 1) + C(2, 2) + d0 x d1 x d2} = 0 + 0 + 3 x 2 x 4 이므로 24이다.

3. f = 1, n = 2, j = 3

|     |  1  |  2  |  3  |
| --- | :-: | :-: | :-: |
| 1   |  0  | 24  |     |
| 2   |     |  0  |  8  |
| 3   |     |     |  0  |

c(2, 3) = min{C(2, 2) + C(3, 3) + d1 x d2 x d3} = 0 + 0 + 2 x 4 x 1 이므로 8이다.

4. f = 2, n = 1, j = 3

|     |  1  |  2  |  3  |
| --- | :-: | :-: | :-: |
| 1   |  0  | 24  | 14  |
| 2   |     |  0  |  8  |
| 3   |     |     |  0  |

C(1, 3) = min{C(1, 1) + C(2, 3) + d0 x d1 x d3, C(1, 2) + C(3, 3) + d0 x d2 x d3} = min (0 + 8 + 3 x 2 x 1, 24 + 0 + 3 x 4 x 1) = min(14, 36) 이므로 14 이다.

C(1, length)을 반환하므로 최소 곱셉횟수는 C(1, 3) = 14 가 된다.

## 성능

위의 알고리즘 소스를 보면 for문이 3중으로 중첩된 것을 볼 수 있다.

O($\sum_{s=1}^{n-1}$[(n - s) X s]) = O($n^3$) 이므로 알고리즘의 시간 복잡도는 O($n^3$)이다.

## Reference

[방송대 컴퓨터과학과 알고리즘 5강](http://press.knou.ac.kr/goods/textBookView.do?condCmdtCode=9788920026935&condLscValue=001&condYr=&condSmst=)
[[DP] 연쇄행렬 최소곱셈 알고리즘](https://huiyu.tistory.com/entry/DP-%EC%97%B0%EC%87%84%ED%96%89%EB%A0%AC-%EC%B5%9C%EC%86%8C%EA%B3%B1%EC%85%88-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)
[[Algorithm] 동적계획법 - 연속 행렬 곱셈 본문](https://twinparadox.tistory.com/183)
